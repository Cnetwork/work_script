# 个人工作脚本集合


## 001 卸载NodeJs脚本
事项         | 备注           |
--------------------|------------------|
脚本语言     | SHELL|
适用系统 | MacOS|
推荐使用场景  | NodeJS出现不可控制错误； 卸载升级等情况|
注意事项     | 需要root运行 |
### 1.1 为什么写

   在工作中需要NodeJs安装一些插件，但是配置过程中（使用国内源及其他步骤）出现错误，无法排查错误，只能卸载，但是NodeJs的文件夹及其杂乱，所以只能写一个脚本把它们一次性删除干净

### 1.2 使用说明

```
# 不需要后台，删的非常快
root sh uninstall_nodejs.sh
```


## 002 拷贝目录并忽略其中的log文件
事项         | 备注           |
--------------------|------------------|
脚本语言     | Python|
适用系统 | Linux|
推荐使用场景  | 需要拷贝目录但是需要过滤某些文件（本脚本内为Log）|
注意事项     | 如果需要过滤其他文件只需要修改第11行的正则表达式就行了 |
### 2.1 为什么写
   2017年11月6日，我需要将worker@10.101.x.x的searcher模块拷贝到另外的一台机器上，然后在另外一台机器上运行 searcher, 简单来说就是把目标文件夹 /home/services/ 搬运到services@10.111.x.x 上，然后运行 start.sh就行了，看起来很简单，直接使用scp就好了，但是出现几个问题  
   
   1. log文件非常多非常大， 总文件夹有104G, 而电脑的剩余空间有限，80多G
   2. log文件不止一处，不排除未知的位置
   3. log文件有两个格式 log.1, abc.log.1, 无法通过shell后缀名判断

所以选择采用了 Python, 基本方法就是遍历文件夹，所有文件名前缀修改为我们的目的地址就可以了, 最后发现有效文件只有123M
    
   

### 2.2 使用实例

```
# 查看帮助
$ python cdwl.py -h
Usage: cdwl.py [options]

Options:
  -h, --help                  show this help message and exit
  -s SRCDIR, --src=SRCDIR     please input source directory
  -d DESTDIR, --dest=DESTDIR  please input destination directory
                        
# 使用实例
$ python cdwl.py -s /home/service  -d /home/service/bak_dir

# 不会有循环引用的错误，脚本先获取列表再建立新的bak_dir，放心使用                      
# 排除了 test.log  test.log.123  log.123等格式
```

## 003 向测试机发送批量搜索请求（测试环境制造流量）
事项         | 备注           |
--------------------|------------------|
脚本语言     |python|
适用系统 |linux|
推荐使用场景  |测试机环境|
注意事项     |注意QPS，别打线上机器|
### 3.1 为什么写
2017年11月20日左右，公司后端只有线上机器，测试环境并未完全搭建好，不能从线上引流过来，所以只能人工的打命令，考虑到命令真实性的问题，所以从线上环境中人肉搬运log文件回来（每次打流量不需要很多，打半小时就够了，全部log文件太多了，所以没有写脚本全部实时搬运），然后把log中的请求命令拿出来，包装一下，打到测试机上，每次这么人肉总比直接上线要强一点，等着引流搭建完成。

### 3.2 使用实例

```
配置了一个start.sh 直接 sh start.sh即可
在start.sh 中可以配置参数：
TARGET_IP  目标测试主机及端口 如"10.111.0.54:8041"
THROUGHPUT 吞吐量 总共打多少条命令过去 如100000
SRCLOG     线上Log文件，我们的命令就是从这里获取的，要先从线上搬运过来，放在文件夹里 如"./ServerLog/origin_log/log.6"
QPS        query per second， 注意测试机承载的极限，如40
QUERYTYPE  我们最终筛选出来的request类型，有三种选择"match"或 “search”或两者都有
OWNLOG     start.sh的log文件 如"/home/services/wangshuguang/bulk_test/Logs/bt_test.log"

直接执行吧，只是打个流量而已
```

-----
## 004 越过跳板机向server机器传输jar包（同时完成备份）
事项         | 备注           |
--------------------|------------------|
脚本语言     |expect|
适用系统 |linux|
推荐使用场景  |本地开发机器如Mac + intelliJ|
注意事项     |在写执行命令时候要在周围没人时候写，看到了就尴尬了|
### 4.1 为什么写
我在工作时候，需要将本地开发jar包跳跃过跳板机进行传输，所以工作流有点复杂，大概有以下几步： 1. 本地jar包打包； 2. 打开terminal登录至跳板机； 3. 跳板机登录到测试机； 4. 测试机进入相关目录； 5. scp逆向传输还要配置相关命令 6. 运行
要是遇到修改错误的情况，那简直是虐人，一次流程手速再快也要一分钟，非常干扰开发思维，所以写了这个脚本，这个expect脚本主要做了两件事

1. 登录到跳板机再登录到指定测试机
2. 在测试机上逆向scp本地的jar包到指定路径

这个脚本的优点在于可以共享，不会泄露个人密码，我用了自动获取命令行参数去处理了，但是在本地输入命令时候还是会不必要的泄露，要是继续改进的话，可以写进shell，再用shell获取密码参数的形式隐藏即可  
__真心的用了这个还能自动登录到测试机上，再也不用手动了,10秒我都嫌慢__

### 4.2 使用实例

```
#在Intellij工程的根目录下我建了一个scripts的文件夹，在这里运行
# 使用说明 expect copyToKVM.exp [跳板机用户名] [跳板机密码] [Mac机器用户名] [Mac用户密码]

$ expect copyToKVM.exp cnetwork 123 cnetwork 4546
```

-----
## 005 jar包启动shell脚本
事项         | 备注           |
--------------------|------------------|
脚本语言     | shell|
适用系统 | Linux|
推荐使用场景  |服务器或测试环境 |
注意事项     | 没啥注意的 |
### 5.1 为什么写
我就是放上来，感觉比较好，jar包启动时候要编辑一些最大最小内存之类的东西，写进脚本特别棒，直接执行就好，新手入门必备！
这个是可以放在crontab里面执行的，因为都配置好了java路径，不存在找不到的问题。

### 5.2 使用实例

```
# 使用实例
sh start.sh 把abc.jar启动（以 com.yidian.cha.abc为入口类）
```
## 006 vim自动生成注释
事项         | 备注           |
--------------------|------------------|
脚本语言     | vimrc|
适用系统 | linux & osx|
推荐使用场景  |适用于任何场景|
注意事项     |推荐使用，无注意事项|
### 6.1 为什么写
使用 vim 编写文件时候经常想添加注释但是又嫌麻烦，所以干脆借鉴网上的大神们的vimrc脚本自己拼凑了一个比较全的版本

![实际效果](https://github.com/Cnetwork/work_script/blob/master/picture/006-01.png)

主要集中了以下几个功能

- 能够判断文件类型生成对应注释信息
- 能够自动生成不同文件头部固定代码
- 含有最近修改时间并能够实时更新
- 增加注释方便新手使用修改
- 自动增加注释以后移动到行尾部
- 对于已有文件增加F2触发按键(使用F2时候切记在头部留足够的空行呀！)

除了F2触发按键有雷以外，其他都还好

### 6.2 使用实例

```
# 将vimrc.comment中的内容补在 ~/.vimrc 后面就好了
cat vimrc.comment >> ~/.vimrc
```

## 007 shell 常用代码
事项         | 备注           |
--------------------|------------------|
脚本语言     | bash|
适用系统 | linux, macos|
推荐使用场景  | 工作场景|
注意事项     | 就是把经常用的代码打一遍|
### 7.1 为什么写

   碰到一本好书（在007文件夹中可以看到），并不是讲shell最基础的命令而是有很多工程上的示范，比如：
   
   ```
   [ -f income.txt ] && echo "This is a file" && .....
   ```
   
   这种工程上的常用代码平时很少有人解释，看到这本书非常喜欢，就把里面的代码都打了一遍，其实最有收获的是前三章，大家可以看看，gitbook上也有，非常感谢作者！

### 7.2 使用实例

```
cd 007*
nohup bash shell_sample.sh income 2>&1 &
```
## 008 CheetSheet生成
事项         | 备注           |
--------------------|------------------|
脚本语言     |ruby或者其他[DSL](http://www.yinwang.org/blog-cn/2017/05/25/dsl)|
适用系统 |所有的|
推荐使用场景  |需要积淀一下技术思路时候|
注意事项     |好工具更重要，但是别太浪费时间了|
### 8.1 为什么写

   之前学Iterm2 的时候想找一个比较好的按键示意图，后来明白我要找的是一个叫“CheetSheet”的东西，相当于核查单了，我就在网上淘了一些工具，比较好用的两个我已经放在008中了，分别是：
   
   - [cheatography.com](http://www.cheatography.com) : 一个cheetSheet的圣地，上面不仅仅有编程类的cheetsheet，而且有各种其他类别比如学习英语，心理学等等，可以在上面写自己的cheetsheet并且发布，导出pdf，非常的好用，唯一的不足是中文支持无力，中文导出Pdf是看不到中文的！我已经写了一个iterm2的 [cheetsheet](https://www.cheatography.com/cnetwork/cheat-sheets/iterm2/)，欢迎大家来看
   - Dash CheetSheet 生成工具 [cheatset](https://github.com/Kapeli/cheatset)：Mac上有一个非常好用的编程文档查询软件叫dash(收费的)，他内部集成了一个工具，用ruby去写，生成后可以放在dash app里，随时查看，算是一个比较好的工具了。
   

### 8.2 使用实例

```
// Cheatography.com 那个直接去网站编辑就好
// 对于Dash 那个 
cheatset generate sample.rb
```
## 009 服务消耗时间统计
事项         | 备注           |
--------------------|------------------|
脚本语言     |python3|
适用系统 | 所有|
推荐使用场景  |别人说你服务慢的时候|
注意事项     |甩锅用|
### 9.1 为什么写
自己写的一个A模块处理速度没什么问题（5ms），接入到另外一个B服务时候，B模块与A模块的交互时间变得很慢（最高能到100ms），这个时候为了证明A服务不是真的慢所以编了这个脚本，主要是通过pycurl获取请求从B出来结果回到B的整个过程，每个小阶段耗时
这几个阶段分别是：

1. 发起请求到DNS时间
2. TCP链接消耗时间
3. 跳转消耗时间
4. SSL握手时间
5. 客户端准备时间
6. 服务器准备时间
7. 传输时间
8. 总耗时

最关键的就是 6+7的和，代表了非网络延迟情况下A模块的实际耗时，这个很重要，后来发现很低很低，确实是网络延时和B模块的一些GC导致的 

### 9.2 使用实例

```
// 把服务请求放到文件里，如command.txt  (http://xxx.xxx.xxx.xxx?&parameter.....)
// python pyc.py [url file]  [qps]
python pyc.py command.txt 100
```

## 010 生成命令行表格
事项         | 备注           |
--------------------|------------------|
脚本语言     | ruby|
适用系统 |macos, linux |
推荐使用场景  |写一些注释时候需要用 |
注意事项     | 安装Ruby先 |
### 10.1 为什么写

   在写注释时候有时候表格更加清楚一些，但是明显在`.java`中插入图片不现实，找了一个小工具可以生成命令行表格, 挺好用的，强烈推荐，让你的代码变得更清晰。
   
### 10.2 使用实例

```
+------------+-------------+-------------+--------------------+-------------+
| 属性       | Channel请求 | Channel请求 | keyword请求        | keyword请求 |
| from_id    | m503949     | null        | null               | null        |
| channel_id | null        | 14414961060 | null               | null        |
| ctype      | null        | null        | video              | weibo       |
| count      | null        | null        | 100                | 1           |
| words      | null        | null        | null               | abc         |
| q          | null        | null        | tag:vtpc_list//646 | null        |
+------------+-------------+-------------+--------------------+-------------+

//对应的代码是：
require 'terminal-table'
  
rows = []
rows << ['属性', 'Channel请求', 'Channel请求', 'keyword请求','keyword请求']
rows << ['from_id', 'm503949', 'null', 'null','null']
rows << ['channel_id','null', '14414961060', 'null','null']
rows << ['ctype', 'null', 'null','video','weibo']
rows << ['count', 'null', 'null','100','1']
rows << ['words', 'null', 'null','null','abc']
rows << ['q','null','null','tag:vtpc_list//646','null']
table = Terminal::Table.new :rows => rows
puts table


```


-----
## 00x 模板
事项         | 备注           |
--------------------|------------------|
脚本语言     | |
适用系统 | |
推荐使用场景  | |
注意事项     |  |
### 1.1 为什么写

   abc

### 1.2 使用实例

```
# 使用实例
```

